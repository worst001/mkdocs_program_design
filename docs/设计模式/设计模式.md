# 设计模式

## 单例模式

### 作用

***类被实例化后只会留有单个实例在内存中***

实现单例模式的关键是确保在程序运行期间只有一个实例被创建。下面介绍几种常见的单例模式实现方式：

#### 饿汉式（Eager Initialization）
在类加载时就创建实例，并在静态变量中保存。这种方式简单直接，但可能会造成资源浪费，因为无论是否使用该实例，都会被创建。

#### 懒汉式（Lazy Initialization）
延迟到需要时才创建实例。可以通过加锁（synchronized）或者双重检查锁定（double-checked locking）来实现线程安全。懒汉式是常见的单例模式实现方式，但在多线程环境下需要注意线程安全问题。

#### 静态内部类
利用类的静态内部类特性，在需要时才加载并初始化实例。这种方式既能实现延迟加载，也能保证线程安全。静态内部类在外部类加载时不会被加载，只有在第一次调用 getInstance() 方法时才会加载内部类，从而实现单例。

#### 枚举类
枚举类是实现单例模式的最佳方式之一。枚举类保证了实例的唯一性，并且在任何情况下都是线程安全的。枚举类不允许通过反射创建新的实例，因此可以防止反射攻击。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/blob/master/singleton/Singleton.cpp)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/singleton)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/singleton/AppRegistry.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/blob/main/Creational/Singleton/Singleton.php)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/creational/borg.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/03_singleton)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Singleton%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/singleton/singleton.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/singleton/singleton_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/singleton.lua)

----------------------------------------

## 工厂模式

### 作用

***可以实例化为不同的类型 可以构建不同类型的工厂***

工厂模式是一种常用的设计模式，它提供了一种创建对象的方式，将对象的实例化过程与使用者解耦，使得代码更加灵活、可扩展和可维护。

#### 简单工厂模式（Simple Factory Pattern）
简单工厂模式通过一个工厂类来创建对象，根据不同的参数返回不同的具体对象。使用者只需知道一个工厂类和对应的参数，而无需关心具体的对象创建过程。这种方式实现了对象的创建与使用的分离，但违反了开放封闭原则，当需要添加新的产品时，需要修改工厂类的代码。

#### 工厂方法模式（Factory Method Pattern）
工厂方法模式定义了一个抽象的工厂接口，由具体的子类工厂来实现创建对象的方法。每个具体的工厂负责创建一种具体的产品对象，使用者通过调用工厂方法来获取所需的产品。这种方式符合开放封闭原则，新增产品时只需增加相应的工厂类即可。

#### 抽象工厂模式（Abstract Factory Pattern）
抽象工厂模式提供了一种创建一系列相关或依赖对象的接口，而无需指定具体的类。抽象工厂定义了多个创建产品的方法，每个具体的工厂实现这些方法来创建一组相关的产品。使用者通过调用具体工厂的方法来获取所需的产品组合。这种方式适用于需要创建一组相关对象的场景，可以保证创建的产品之间的兼容性。

### 简单工厂模板
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/factory)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/factories/simple/Animal.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Creational/SimpleFactory)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/00_simple_factory)

### 工厂方法模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/factory-method)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/factory-method)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/factories/factory_method/DatabaseClient.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Creational/FactoryMethod)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/creational/factory.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/04_factory_method)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Factory%20Method%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/factory/factory.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/factory/factory_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/factoryMethod.lua)

### 抽象工厂模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/abstract-factory)
+ [Java](file:///Users/hanwenhao/Cloud/CodeTemplate/Design/Java/AbstractFactory/App.java)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/factories/abstract_factory/DatabaseConnectorFactory.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Creational/AbstractFactory)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/creational/abstract_factory.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/05_abstract_factory)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Abstract%20Factory%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/abstract-factory/abstract-factory.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/abstract-factory/abstract-factory_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/abstractFactory.lua)

----------------------------------------

## 建造者模式

### 作用

***设置类中的各个组件***

建造者模式（Builder Pattern）是一种创建型设计模式，它提供了一种构建复杂对象的解决方案，通过将构建过程拆分为多个步骤，并允许按照特定顺序逐步构建对象。

建造者模式的核心思想是将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。这样可以使得构建过程更加灵活，同时避免在构建过程中产生不必要的耦合。

#### 建造者模式通常包含以下几个角色：

+ Builder（建造者）：定义用于构建产品的抽象接口，声明构建产品各个部分的方法。
+ ConcreteBuilder（具体建造者）：实现Builder接口，实现各个部分的具体构建方法，并定义获取最终产品的方法。
+ Product（产品）：表示被构建的复杂对象，包含多个部分。
+ Director（指挥者）：负责安排Builder的调用顺序，控制构建过程。

#### 建造者模式的工作流程如下：

+ 客户端创建Director对象，并传入对应的ConcreteBuilder对象。
+ Director按照一定的顺序调用ConcreteBuilder的方法来构建产品的各个部分。
+ 最终，客户端通过调用ConcreteBuilder的获取结果方法，从ConcreteBuilder中获取构建完成的产品。

#### 建造者模式适用于以下场景：

+ 当需要创建复杂对象时，且构建过程有多个步骤或可选部分时。
+ 当需要构建的产品具有不同的表示时，但构建过程相同。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/builder)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/builder)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/builder/case_classes/Person.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Creational/Builder)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/creational/builder.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/06_builder)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Builder%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/builder/builder.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/builder/builder_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/builder.lua)

----------------------------------------

## 原型模式

### 作用

***以某个原型为蓝本创建实例***

原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而无需依赖于显式的实例化过程。

在原型模式中，定义一个原型对象作为创建其他对象的基础。原型对象是一个已经存在的对象实例，我们可以通过对它进行克隆（即复制）来创建新的对象实例，这个过程不需要调用类的构造函数。

#### 原型模式通常包含以下几个角色

+ Prototype（原型）：定义一个接口或抽象类，声明克隆方法clone()。
+ ConcretePrototype（具体原型）：实现Prototype接口或继承抽象类，实现克隆方法clone()。
+ Client（客户端）：使用原型对象的客户端代码。

#### 原型模式的工作流程如下

+ 客户端创建一个原型对象，并通过原型对象的clone()方法复制自身，得到一个新的对象实例。
+ 可选地，客户端可以对新的对象实例进行个性化的设置或修改。
+ 客户端使用新的对象实例进行后续操作。

#### 原型模式适用于以下场景

+ 当创建新对象的过程复杂、耗时且需要频繁创建时，可以使用原型模式来提高创建效率。
+ 当需要避免直接依赖于类的构造函数来创建对象时，可以使用原型模式来复制现有对象。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/prototype)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/prototype)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/creational-design-patterns/src/main/scala/com/ivan/nikolov/creational/prototype/Cell.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Creational/Prototype)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/creational/prototype.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/07_prototype)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Creational%20Patterns/Prototype%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/prototype/prototype.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/creational/prototype/prototype_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/protoType.lua)

----------------------------------------

## 适配器模式

### 作用

***构建适配器将其他类翻译成当前类可识别的类***

适配器模式（Adapter Pattern）是一种结构型设计模式，它允许不兼容接口的类之间进行合作。适配器模式将一个类的接口转换为客户端所期望的另一个接口，从而使得原本由于接口不匹配而无法工作的类可以一起工作。

#### 适配器模式通常包含以下几个角色

+ 目标接口（Target Interface）：客户端期望的接口，也就是客户端希望使用的方法。
+ 适配器（Adapter）：实现目标接口，并将请求转发给被适配者。
+ 被适配者（Adaptee）：需要被适配的类或对象，它定义了不兼容目标接口的方法。
+ 客户端（Client）：通过目标接口与适配器进行交互。

#### 适配器模式的工作流程如下

+ 客户端调用目标接口中的方法。
+ 适配器接收到请求后，在内部调用被适配者的方法进行处理。
+ 被适配者执行对应的操作并返回结果。
+ 适配器将结果返回给客户端，作为目标接口的响应。

#### 适配器模式适用于以下场景：

当需要使用一个已经存在的类，但其接口与需要的接口不匹配时，可以使用适配器模式进行转换。
当需要复用一些现有的类，并且这些类的接口与其他类或系统不兼容时，可以使用适配器模式进行适配。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/adapter)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/adapter)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/adapter/AppLogger.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Adapter)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/adapter.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/02_adapter)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Adapter%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/adapter/adapter.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/adapter/adapter_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/adapter.lua)

----------------------------------------

## 桥接模式

### 作用

***拆分类中的抽象逻辑 具象化时桥接它们***

桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分和实现部分分离，使它们可以独立地变化。桥接模式通过将继承关系转化为组合关系，从而降低了类之间的耦合性，并提供了更好的灵活性和可扩展性。

#### 桥接模式通常包含以下几个角色

+ 抽象部分（Abstraction）：定义抽象部分的接口，同时保存一个对实现部分对象的引用。
+ 扩展抽象部分（Refined Abstraction）：在抽象部分基础上进行扩展，实现更多功能。
+ 实现部分（Implementor）：定义实现部分的接口，为抽象部分提供具体的实现方法。
+ 具体实现部分（Concrete Implementor）：实现实现部分接口的具体类。

#### 桥接模式适用于以下场景

+ 当需要避免在抽象部分和实现部分之间存在固定的绑定关系时，可以使用桥接模式。
+ 当需要在多个维度上独立扩展类的功能时，可以使用桥接模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/bridge)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/bridge)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/tree/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/bridge)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Bridge)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/bridge.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/22_bridge)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Bridge%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/bridge/bridge.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/bridge/bridge_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/bridge.lua)

----------------------------------------

## 组合模式

### 作用

***整体与部分可以自由组合的结构 如树形结构***

组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

#### 组合模式通常包含以下几个角色

+ 组件（Component）：定义组合中对象的共同接口，可以是抽象类或接口。它定义了管理子组件的方法，以及其他操作方法。
+ 叶子节点（Leaf）：表示组合中的叶子节点对象，它没有子节点。
+ 容器节点（Composite）：表示组合中的容器节点对象，它可以包含子节点。容器节点实现了组件接口，并提供了管理子节点的方法。
+ 客户端（Client）：通过组件接口来操作组合对象。

组合模式的关键思想是使用递归的方式构建树形结构，使得客户端可以以统一的方式处理单个对象和组合对象。
组合模式通过将对象组织成树状结构，使得用户可以像处理单个对象一样处理整个树结构，而不需要区分是单个对象还是组合对象。

#### 组合模式适用于以下场景

+ 当希望将对象组织成树形结构，并且希望客户端能够以统一的方式处理树中的所有对象时，可以使用组合模式。
+ 当希望对对象进行部分-整体的层次结构表示，并且希望能够忽略单个对象和组合对象之间的差异时，可以使用组合模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/composite)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/composite)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/composite/Node.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Composite)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/composite.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/13_composite)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Composite%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/composite/composite.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/composite/composite_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/component.lua)

----------------------------------------

## 装饰器模式

### 作用

***基于原有类的基础行为上做进一步补充行为***

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许在不改变原有对象结构的情况下，动态地给对象添加额外的功能和责任。

#### 装饰器模式通常包含以下几个角色

+ 抽象构件（Component）：定义了原始对象和装饰器共同实现的接口。
+ 具体构件（Concrete Component）：表示被装饰的原始对象，实现了抽象构件的接口。
+ 装饰器（Decorator）：持有一个抽象构件的引用，并实现了抽象构件的接口。它可以通过继承或组合的方式来增加额外的功能。
+ 具体装饰器（Concrete Decorator）：具体的装饰器类，实现了装饰器的接口并提供了具体的装饰逻辑。

装饰器模式的核心思想是通过包装（即装饰）原始对象，以实现对其功能的扩展，同时又保持了原始对象的接口不变。

#### 装饰器模式的工作流程如下

+ 客户端创建一个具体构件对象。
+ 客户端根据需要，使用一个或多个具体装饰器对象进行装饰。每个装饰器对象都持有一个抽象构件的引用，并可以对抽象构件进行装饰。
+ 装饰器对象在装饰过程中，可以添加额外的功能或责任。
+ 最终，客户端通过调用具体装饰器的方法来操作被装饰后的对象。

#### 装饰器模式适用于以下场景

+ 当需要动态地给对象添加功能和责任，而又不希望使用子类继承的方式进行扩展时，可以使用装饰器模式。
+ 当需要为多个独立的对象添加相似的功能时，可以使用装饰器模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/decorator)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/decorator)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/decorator/InputReaderDecorator.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Decorator)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/decorator.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/20_decorator)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Decorator%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/decorator/decorator.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/decorator/decorator_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/decorator.lua)

----------------------------------------

## 外观模式

### 作用

***集合复杂功能 向外部提供简单接口***

外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口，用于访问子系统中一组复杂的接口。外观模式通过封装子系统的复杂性，简化了客户端与子系统之间的交互。

#### 外观模式通常包含以下几个角色

+ 外观（Facade）：提供了一个高层次的接口，封装了对子系统的访问和调用。外观模式的客户端只需要与外观对象进行交互，而不需要直接与子系统进行交互。
+ 子系统（Subsystems）：由多个类或对象组成的一组复杂子系统。每个子系统负责处理特定的任务或功能。

外观模式的核心思想是通过引入一个外观对象，将客户端与子系统之间的复杂交互变得简单。客户端只需要通过调用外观对象的方法来完成相关操作，而不需要了解子系统内部的具体细节。

#### 外观模式的工作流程如下

+ 客户端通过创建外观对象来访问子系统。
+ 客户端调用外观对象的方法，外观对象在内部协调和调用子系统的相应方法。
+ 子系统根据外观对象的请求来执行相应的功能并返回结果给外观对象。
+ 外观对象将子系统的结果返回给客户端。

#### 外观模式适用于以下场景

+ 当需要简化复杂子系统的接口，提供一个统一的高层次接口时，可以使用外观模式。
+ 当需要解耦客户端与子系统之间的依赖关系，并且希望通过一个中间层来隔离变化时，可以使用外观模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/facade)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/facade)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/facade/DataReader.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Facade)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/facade.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/01_facade)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Facade%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/facade/facade.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/facade/facade_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/facade.lua)

----------------------------------------

## 享元模式

### 作用

***为高重复的对象建一个共享池***

享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来有效地支持大量细粒度的对象。享元模式通过将对象的状态划分为内部状态（Intrinsic State）和外部状态（Extrinsic State），并共享内部状态来减少对象的数量。

#### 享元模式通常包含以下几个角色

+ 享元接口（Flyweight）：定义了享元对象的接口，包括操作内部状态的方法。
+ 具体享元（Concrete Flyweight）：实现享元接口，并保存内部状态。
+ 享元工厂（Flyweight Factory）：负责创建和管理享元对象，提供获取享元对象的方法。

享元模式的核心思想是将对象的状态分为内部状态和外部状态。内部状态是可以被多个对象共享的，而外部状态是每个对象独立拥有的。通过共享内部状态，可以减少对象的数量，节省内存空间，并提高系统的性能。

#### 享元模式的工作流程如下

+ 客户端通过享元工厂获取享元对象。
+ 客户端设置享元对象的外部状态。
+ 客户端使用享元对象进行相应的操作，享元对象根据外部状态进行处理。
+ 当不再需要使用享元对象时，客户端可以将其释放，并返回给享元工厂。

#### 享元模式适用于以下场景

+ 当需要支持大量细粒度的对象，且这些对象可以共享相同的内部状态时，可以使用享元模式。
+ 当需要节省内存空间，提高系统性能，并且可以通过外部状态来区分对象时，可以使用享元模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/flyweight)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/flyweight)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/flyweight/Circle.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Flyweight)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/flyweight.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/18_flyweight)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Flyweight%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/flyweight/flyweight.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/flyweight/flyweight_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/flyweight.lua)

----------------------------------------

## 代理模式

### 作用

***代理某个类 其行为应该受限***

代理模式（Proxy Pattern）是一种结构型设计模式，它提供了一个代理对象来控制对原始对象的访问。通过使用代理对象，可以实现对原始对象的间接访问，从而在不改变原始对象的情况下增加额外的功能。

#### 代理模式通常包含以下几个角色
+ 抽象主题（Subject）：定义了真实主题和代理对象共同实现的接口，这样客户端就可以通过抽象主题来访问真实主题。
+ 真实主题（Real Subject）：实现了抽象主题定义的接口，代表了真正需要被访问的对象。
+ 代理（Proxy）：保存了对真实主题对象的引用，并实现了抽象主题定义的接口。在访问真实主题之前或之后，代理可以执行一些额外的操作。

代理模式的核心思想是通过引入一个代理对象来间接地控制对原始对象的访问。代理对象充当了客户端与真实对象之间的中介，隐藏了真实对象的具体实现细节，并提供了额外的功能。

#### 代理模式的工作流程如下
+ 客户端通过创建代理对象来访问真实对象。
+ 代理对象在内部保存了对真实对象的引用，并在必要时调用真实对象的方法。
+ 在调用真实对象的方法之前或之后，代理对象可以执行一些额外的操作。

#### 代理模式适用于以下场景
+ 当需要控制对原始对象的访问，并在访问过程中增加额外功能时，可以使用代理模式。
+ 当需要隐藏真实对象的具体实现细节，并提供统一的接口给客户端时，可以使用代理模式。


### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/proxy)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/proxy)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/structural-design-patterns/src/main/scala/com/ivan/nikolov/structural/proxy/FileReader.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Structural/Proxy)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/structural/proxy.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/09_proxy)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Structural%20Patterns/Proxy%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/flyweight/flyweight.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/structural/flyweight/flyweight_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/flyweight.lua)

----------------------------------------

## 责任链模式

### 作用

***将解耦请求和接受后的模块划分为若干责任块 以链表形式构建***

责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象按照顺序处理同一个请求，直到其中一个对象能够处理该请求为止。责任链模式将请求发送者和接收者解耦，并且使得多个对象都有机会处理请求。

#### 责任链模式通常包含以下几个角色
+ 抽象处理者（Handler）：定义了处理请求的接口，并持有下一个处理者的引用。通常包含处理请求的方法。
+ 具体处理者（Concrete Handler）：实现抽象处理者接口，负责处理请求。如果自己无法处理请求，则将请求传递给下一个处理者。
+ 客户端（Client）：创建责任链，并将请求发送给第一个处理者。

责任链模式的核心思想是将多个处理者组成一个链条，每个处理者都有机会处理请求。当一个处理者无法处理请求时，将请求传递给下一个处理者，直到有一个处理者能够处理请求为止。

#### 责任链模式的工作流程如下
+ 客户端创建责任链，并将请求发送给第一个处理者。
+ 每个处理者根据自己的处理能力判断是否能够处理请求，如果能够处理则进行处理，否则将请求传递给下一个处理者。
+ 当某个处理者成功处理请求后，停止向下传递请求。

#### 责任链模式适用于以下场景
+ 当有多个对象可以处理同一请求，且具体由哪个对象处理是在运行时动态决定的时候，可以使用责任链模式。
+ 当希望将请求发送者和接收者解耦，以及避免请求发送者和接收者之间的直接依赖关系时，可以使用责任链模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/chain-of-responsibility)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/chain-of-responsibility)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/chain_of_responsibility/ATM.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/ChainOfResponsibilities)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/chain_of_responsibility.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/21_chain_of_responsibility)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Chain%20of%20Responsibility%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/chain-of-resp/chain-of-resp.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/chain-of-resp/chain-of-resp-es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/responeChain.lua)

----------------------------------------

## 命令模式

### 作用

***命令方向接收方下达一条命令 驱动接收方完成某项任务***

命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而使得可以用不同的请求来参数化客户端对象。命令模式允许请求的发送者和接收者解耦，以及支持请求的排队、记录和撤销操作。

#### 命令模式通常包含以下几个角色
+ 命令接口（Command）：定义了执行命令的方法。
+ 具体命令（Concrete Command）：实现了命令接口，负责执行具体的操作。通常会持有一个接收者对象，并调用接收者的方法来完成请求。
+ 接收者（Receiver）：执行具体的操作，是命令的实际执行者。
+ 调用者（Invoker）：负责创建命令对象，并将请求发送给命令对象执行。

命令模式的核心思想是将请求封装成一个命令对象，从而使得请求的发送者和接收者解耦。通过将请求参数化，可以灵活地将不同的请求与具体的操作进行绑定，并支持请求的排队、记录和撤销。

#### 命令模式的工作流程如下
+ 客户端创建具体的命令对象，并设置命令的接收者。
+ 客户端将命令对象传递给调用者。
+ 调用者接收到命令对象后，调用命令对象的执行方法。
+ 命令对象执行具体的操作，将请求传递给接收者来完成。

#### 命令模式适用于以下场景
+ 当需要将请求的发送者和接收者解耦，以及支持请求的排队、记录和撤销时，可以使用命令模式。
+ 当需要对不同的请求进行参数化，并且能够灵活地切换和扩展命令时，可以使用命令模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/command)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/command)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/command/RobotCommand.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Command)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/command.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/11_command)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Command%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/command/command.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/command/command_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/command.lua)

----------------------------------------

## 解释器模式

### 作用

***解释一段文本的文法 上下文之间如何作用***
> 一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。
> 你为了使他们运行，就要给所有的外部变量一个一个写一些值进去，这些值的集合叫上下文。

解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义语言的文法规则，并且解析和执行对应的表达式。解释器模式通过将每个文法规则表示为一个类的层次结构，并使用递归调用来解释和执行表达式。

#### 解释器模式通常包含以下几个角色
+ 抽象表达式（Abstract Expression）：定义了解释器的接口，声明了解释方法interpret()。
+ 终结符表达式（Terminal Expression）：实现了抽象表达式接口，表示文法规则中的终结符。终结符表达式通常是解释器模式的叶子节点。
+ 非终结符表达式（Nonterminal Expression）：实现了抽象表达式接口，表示文法规则中的非终结符。非终结符表达式通常是解释器模式的内部节点。
+ 上下文（Context）：包含了需要解释的表达式或文本，并提供相应的解释方法。

解释器模式的核心思想是将语言的文法规则表示为对象的层次结构，并使用解释器来解释和执行对应的表达式。每个表达式都可以通过递归调用的方式进行解释，最终得到结果。

#### 解释器模式的工作流程如下

+ 客户端创建并配置上下文对象，将需要解释的表达式或文本传递给上下文。
+ 客户端创建相应的抽象表达式对象，并构建它们的层次结构。
+ 客户端调用根节点的interpret()方法来执行解释和执行操作。

#### 解释器模式适用于以下场景
+ 当需要定义一种语言的文法规则，并且希望能够解析和执行对应的表达式时，可以使用解释器模式。
+ 当有一些简单的规则组合成复杂的规则，并且需要灵活地进行解释和执行时，可以使用解释器模式。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/interpreter)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/interpreter)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/interpreter/Expression.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Interpreter)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/19_interpreter)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Interpreter%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/interpreter/interpreter.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/interpreter/interpreter_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/interpreter.lua)

----------------------------------------

## 迭代器模式

### 作用

***提供外部可以顺序访问对象的接口***

迭代器模式是一种行为型设计模式，它提供了一种访问集合对象元素的方法，而无需暴露集合内部的表示细节。通过使用迭代器模式，我们可以遍历一个集合对象中的元素，而不需要关心集合的具体实现方式。

#### 在迭代器模式中，有两个核心角色：迭代器（Iterator）和容器（Container）。
+ 迭代器（Iterator）：迭代器是负责定义访问和遍历集合元素的接口。它提供了一系列的方法，如获取下一个元素、判断是否还有下一个元素等。通过迭代器，客户端代码可以依次访问集合中的元素，而不需要了解集合的内部结构。
+ 容器（Container）：容器是负责存储和管理元素的集合对象。容器类通常会提供一个获取迭代器的方法，用于返回一个对应的迭代器对象。这样，客户端代码可以通过迭代器来访问容器中的元素，而不需要直接操作容器对象。

#### 迭代器模式的工作流程如下
+ 定义迭代器接口：创建一个迭代器接口，定义用于访问和遍历集合元素的方法，如next()、hasNext()等。
+ 创建容器类：创建一个容器类，实现容器接口，并提供获取迭代器的方法。容器类内部可以使用数组、链表等数据结构来存储元素。
+ 实现迭代器类：创建一个迭代器类，实现迭代器接口。迭代器类需要维护一个指向当前元素的游标，并根据具体情况实现相应的方法。
+ 使用迭代器：客户端代码通过容器类获取迭代器对象，然后使用迭代器的方法进行遍历和访问集合中的元素。

#### 迭代器模式的优点包括
+ 将集合对象的遍历与具体的集合实现分离，提高了代码的可维护性和灵活性。
+ 对于不同类型的集合，可以使用相同的迭代器接口进行访问，提高了代码的复用性。
+ 客户端代码可以逐个访问集合中的元素，而无需关心集合内部的具体结构。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/iterator)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/iterator)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/iterator/Student.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Iterator)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/iterator_alt.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/12_iterator)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Iterator%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/iterator/iterator.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/iterator/iterator_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/iterator.lua)

----------------------------------------

## 中介者模式

### 作用

***使一个类可以通过中介和另一个类产生联系***

中介者模式是一种行为型设计模式，它通过引入一个中介者对象，将多个对象之间的交互行为解耦，使得这些对象之间可以松散耦合地进行通信和协作。

#### 在中介者模式中，有以下几个核心角色
+ 中介者（Mediator）：中介者是一个接口或抽象类，定义了对象之间交互的方法。它通常会持有对各个对象的引用，并负责协调它们之间的通信。中介者知道每个对象的存在，并能够对它们进行管理和控制。
+ 具体中介者（Concrete Mediator）：具体中介者是中介者接口的实现类，它实现了对象之间交互的具体逻辑。具体中介者通常会维护一个对象的集合，并根据不同的交互需求来调度和协调这些对象之间的通信。
+ 同事对象（Colleague）：同事对象是指需要进行通信和协作的对象。同事对象之间相互独立，它们通过中介者来进行通信，而不是直接与其他同事对象进行交互。

在中介者模式中，当一个对象需要与其他对象进行通信时，它并不直接与目标对象进行交互，而是通过中介者来发送消息或请求。中介者接收到消息后，可以根据具体的逻辑决定如何处理，并将消息传递给相应的对象。这样，对象之间的交互行为被集中在中介者中进行管理，从而实现了对象之间的解耦。

#### 中介者模式的优点包括
+ 减少了对象之间的直接依赖，使得对象之间的通信更加灵活和可扩展。
+ 将对象之间的交互逻辑集中在中介者中，使得系统更易于维护和理解。
+ 可以减少子类的数量，因为各个对象之间的交互行为被移到了中介者中。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/mediator)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/mediator)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/mediator/Student.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Mediator)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/mediator.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/08_mediator)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Mediator%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/mediator/mediator.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/mediator/mediator_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/mediator.lua)

----------------------------------------

## 备忘录模式

### 作用

***保存实例的副本以便需要时恢复 如游戏记录 事务***

备忘录模式是一种行为型设计模式，它提供了一种保存和恢复对象状态的方法，使得对象可以在不破坏封装性的前提下，将自身的状态保存到外部，并在需要时恢复到之前的状态。

#### 在备忘录模式中，有以下几个核心角色
+ 发起人（Originator）：发起人是需要保存和恢复状态的对象。它将自身的状态保存到备忘录对象中，并可以从备忘录对象中恢复到之前的状态。
+ 备忘录（Memento）：备忘录是用于存储发起人对象状态的对象。备忘录通常会保存发起人的内部状态，可以是一个快照、一个状态历史记录或者其他形式。
+ 管理者（Caretaker）：管理者是负责管理备忘录对象的对象。它可以存储多个备忘录对象，提供保存和获取备忘录的方法，并可根据需求决定何时使用备忘录进行状态的恢复。

#### 备忘录模式的工作流程如下
+ 发起人创建备忘录：发起人对象通过创建一个备忘录对象，将自身的状态保存到备忘录中。
+ 发起人恢复状态：如果需要恢复到之前的状态，发起人可以从备忘录对象中获取之前保存的状态，并将自身的状态进行恢复。

#### 备忘录模式的优点包括
+ 提供了一种可以在不破坏封装性的前提下保存和恢复对象状态的方法。
+ 可以将对象的状态保存到外部，避免了状态信息的丢失。
+ 发起人对象与备忘录对象之间相互分离，使得发起人对象的状态管理更加简单。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/memento)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/memento)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/memento/Memento.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Memento)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/memento.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/17_memento)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Memento%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/memento/memento.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/memento/memento_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/memento.lua)

----------------------------------------

## 观察者模式

### 作用

***一个实例发生变化时通知所有依附于它的观察者***

观察者模式是一种行为型设计模式，它定义了一种对象之间的一对多依赖关系，使得当一个对象状态发生变化时，其相关依赖对象都能够得到通知并自动更新。

#### 在观察者模式中，有以下几个核心角色：
+ 主题（Subject）：主题是被观察的对象，它维护了一组观察者对象，并提供了用于添加、删除和通知观察者的方法。主题通常会包含一个状态，当状态发生变化时，会通知所有注册的观察者。
+ 观察者（Observer）：观察者是依赖于主题的对象，它定义了一个更新接口，用于接收主题的通知并进行相应的操作。观察者可以订阅一个或多个主题，以便获取所关注的主题的状态变化信息。
+ 具体主题（Concrete Subject）：具体主题是主题接口的实现类，它维护了一组观察者对象，并在状态发生变化时通知观察者。具体主题中通常还包含了特定的业务逻辑。
+ 具体观察者（Concrete Observer）：具体观察者是观察者接口的实现类，它实现了更新接口，在接收到主题的通知时进行相应的处理。具体观察者可以根据需要自定义自己的业务逻辑。

#### 观察者模式的工作流程如下
+ 主题注册观察者：观察者将自身注册到主题中，订阅所关注的主题。
+ 主题状态变化：主题对象的状态发生变化，比如数据更新或事件触发。
+ 主题通知观察者：主题遍历已注册的观察者列表，并调用每个观察者的更新方法，将状态变化的信息传递给观察者。
+ 观察者更新操作：每个观察者接收到主题的通知后，根据自身的业务逻辑进行相应的更新操作。

#### 观察者模式的优点包括
+ 松耦合：主题和观察者之间通过接口进行通信，彼此之间相互解耦，使得它们可以独立地进行修改和扩展。
+ 可扩展性：可以方便地增加新的观察者，以及定义新的主题，而无需修改现有代码。
+ 实时性：当主题的状态发生变化时，观察者可以立即获取到通知并做出相应的反应。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/observer)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/observer)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/observer/Observer.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Observer)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/observer.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/10_observer)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Observer%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/observer/observer.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/observer/observer_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/observer.lua)

----------------------------------------

## 状态模式

### 作用

***实例的行为依据实例的依赖状态***

状态模式是一种行为型设计模式，它允许对象在内部状态发生改变时改变其行为，看起来就像是改变了其类一样。状态模式将对象的行为封装在不同的状态类中，使得对象在不同的状态下可以有不同的行为。

#### 在状态模式中，有以下几个核心角色
+ 环境类（Context）：环境类是拥有状态的对象，它维护一个对抽象状态类的引用，并在需要时将请求委托给当前状态对象进行处理。
+ 抽象状态类（State）：抽象状态类定义了一个接口，用于封装与环境类相关的某个具体状态的行为。
+ 具体状态类（Concrete State）：具体状态类是抽象状态类的实现，它实现了在特定状态下的行为。

#### 状态模式的工作流程如下
+ 定义状态接口：创建一个抽象状态类，定义该状态下可能发生的操作方法。
+ 创建具体状态类：针对不同的状态，创建相应的具体状态类，实现抽象状态类定义的操作方法。
+ 在环境类中维护状态对象：在环境类中维护一个对抽象状态类的引用，并提供设置状态和执行操作的方法。
+ 根据状态调用操作：根据环境类的状态，在相应的状态对象中执行对应的操作。

#### 状态模式的优点包括
+ 将状态相关的行为封装在不同的状态类中，使得代码结构清晰，易于理解和维护。
+ 增加新的状态类相对容易，无需修改已有代码，符合开闭原则。
+ 将状态转换逻辑集中到环境类中，避免了状态切换代码分散在各个业务逻辑中的问题。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/state)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/state)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/state/State.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/State)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/state.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/16_state)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/State%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/state/state.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/state/state_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/state.lua)


----------------------------------------

## 策略模式

### 作用

***根据不同的策略一类行为会产生不同的分析结果***

策略模式是一种行为型设计模式，它定义了一族可互相替换的算法或行为，并使得算法的选择和使用与算法本身独立，从而可以动态地改变对象的行为。

#### 在策略模式中，有以下几个核心角色
+ 环境类（Context）：环境类是使用策略的对象，它持有一个策略对象的引用，并将具体的任务委托给策略对象进行执行。
+ 抽象策略类（Strategy）：抽象策略类定义了一个公共接口，用于封装具体策略类的不同行为。
+ 具体策略类（Concrete Strategy）：具体策略类是抽象策略类的实现，它实现了抽象策略类定义的接口，并提供具体的算法或行为。

#### 策略模式的工作流程如下
+ 定义策略接口：创建一个抽象策略类，定义策略类需要实现的方法。
+ 创建具体策略类：针对不同的算法或行为，创建相应的具体策略类，实现抽象策略类定义的方法。
+ 在环境类中使用策略：在环境类中持有一个策略对象的引用，并在需要执行任务时，调用策略对象的方法。
+ 根据需求选择具体策略：根据具体需求，选择合适的具体策略类作为环境类中的策略对象。

#### 策略模式的优点包括
+ 提供了一种简洁、灵活的方式来处理多个算法或行为的变化和切换。
+ 将策略的选择和使用与策略本身的实现相分离，使得客户端代码与具体策略类解耦。
+ 增加新的策略相对容易，无需修改已有代码，符合开闭原则。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/strategy)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/strategy)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/strategy/ParsingStrategy.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Strategy)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/strategy.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/15_strategy)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Strategy%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/strategy/strategy.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/strategy/strategy_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/strategy.lua)


----------------------------------------

## 模板方法模式

### 作用

***在父类中定义行为的大致框架 所有子类都有相似的行为***

模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，并允许子类在不改变算法结构的情况下，重新定义算法中的某些步骤。

#### 在模板方法模式中，有以下几个核心角色
+ 抽象类（Abstract Class）：抽象类定义了一个模板方法，该方法定义了算法的骨架，包含一系列的步骤。其中部分步骤可以是具体实现，部分步骤则可以是抽象方法，留给子类进行实现。
+ 具体类（Concrete Class）：具体类继承自抽象类，实现了抽象类中定义的抽象方法，并重写其中需要特定实现的步骤。具体类可以根据需要改变或增加算法的某些步骤，但整体算法的结构保持不变。

#### 模板方法模式的工作流程如下
+ 定义模板方法：在抽象类中定义一个模板方法，描述算法的骨架，包含一系列的步骤，其中部分步骤可以是具体实现，部分步骤则可以是抽象方法。
+ 实现具体步骤：在具体类中实现抽象类中定义的抽象方法，并根据需要重写其中需要特定实现的步骤。
+ 调用模板方法：客户端通过调用抽象类中的模板方法来执行算法。在执行过程中，具体步骤会根据具体类的实现而发生变化。

#### 模板方法模式的优点包括
+ 提供了一种固定的算法结构，能够保持算法的稳定性和一致性。
+ 可以通过继承和重写来灵活地改变和扩展某些步骤的实现，而无需修改整个算法的结构。
+ 将算法的通用部分放在抽象类中实现，避免了重复代码，提高了代码的重用性。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/template-method)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/template-method)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/template/DataFinder.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/TemplateMethod)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/template.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/14_template_method)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Template%20Method%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/template/template.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/template/template_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/template.lua)


----------------------------------------

## 访问者模式

### 作用

***一类实例对于不同的访问者 行为会有变化***

访问者模式是一种行为型设计模式，它允许在不改变被访问对象结构的前提下，定义对该对象结构中各元素进行操作的新操作。

#### 在访问者模式中，有以下几个核心角色
+ 抽象访问者（Visitor）：抽象访问者定义了一个访问方法，用于声明对各元素的访问操作。它通常会根据不同的元素类型进行方法的重载或多态处理。
+ 具体访问者（Concrete Visitor）：具体访问者是抽象访问者的实现类，它实现了对各元素的具体访问操作。每个具体访问者可以定义自己特定的访问逻辑。
+ 抽象元素（Element）：抽象元素定义了一个接受访问者对象的接口，该接口通常包含一个接收访问者的方法。它可以是一个单独的接口，也可以是一个抽象类。
+ 具体元素（Concrete Element）：具体元素是抽象元素的实现类，它实现了接收访问者的方法。具体元素会将自身作为参数传递给访问者对象，从而使访问者能够访问和操作该元素。
+ 对象结构（Object Structure）：对象结构是一个复杂的结构，它包含一组元素对象。通常，它会提供一个接受访问者的方法，用于将访问者应用于每个元素。

#### 访问者模式的工作流程如下
+ 定义抽象访问者：创建一个抽象访问者类，声明访问不同元素的方法。
+ 定义抽象元素：创建一个抽象元素类，声明接收访问者的方法。
+ 创建具体元素：针对不同类型的元素，创建相应的具体元素类，并实现接收访问者的方法。
+ 创建具体访问者：创建具体访问者类，实现抽象访问者中定义的访问方法，完成对元素的具体操作。
+ 在对象结构中应用访问者：在对象结构中，调用每个元素的接收访问者方法，将具体访问者应用于每个元素。

#### 访问者模式的优点包括
+ 可以在不改变元素结构的情况下，增加新的操作或行为。
+ 将数据结构与对数据的操作分离，使得代码更加清晰和易于扩展。
+ 符合开闭原则，增加新的访问者类不需要修改现有代码。

### 模板
+ [C++](https://github.com/JakubVojvoda/design-patterns-cpp/tree/master/visitor)
+ [Java](https://github.com/iluwatar/java-design-patterns/tree/master/visitor)
+ [Scala](https://github.com/nikolovivan/scala-design-patterns/blob/master/behavioral-design-patterns/src/main/scala/com/ivan/nikolov/behavioral/visitor/Visitor.scala)
+ [PHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP/tree/main/Behavioral/Visitor)
+ [Python](https://github.com/faif/python-patterns/blob/master/patterns/behavioral/visitor.py)
+ [Go](https://github.com/senghoo/golang-design-pattern/tree/master/23_visitor)
+ [Unity](https://github.com/QianMo/Unity-Design-Pattern/tree/master/Assets/Behavioral%20Patterns/Visitor%20Pattern)
+ [JS-ES5](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/visitor/visitor.js)
+ [JS-ES6](https://github.com/fbeline/design-patterns-JS/blob/master/src/behavioral/visitor/visitor_es6.js)
+ [Lua](https://github.com/woshihuo12/LuaDesignPattern/blob/master/visitor.lua)

## 模式之间的比较

### Object Pool 模式与 Flyweight 模式

Object Pool 模式与 Flyweight 模式确实在高层次目标上有些相似之处，都是旨在优化资源使用和性能，但它们在目的、应用场景和实现方式上有显著区别。

Object Pool 模式的关键在于重用和共享一组已经初始化好的对象集合，通常是对一些创建开销较大的对象。这种模式通常用于限制对象数量，减少实例化和销毁带来的性能消耗，比如数据库连接池、线程池等。一旦对象池中的对象被取出使用后，该对象会从池中移除，待使用完毕后再放回池中，以便再次重用。

Flyweight 模式的核心在于共享细粒度对象，通过将这些对象的共享状态（内蕴状态）与非共享状态（外蕴状态）区分开来达到节省内存的目的。不同于Object Pool，在Flyweight模式中，一个Flyweight对象可以被多个上下文同时使用，并不需要等待释放后再被其他上下文使用。这种模式广泛应用于处理大量小粒度对象的共享，比如字符对象、图形对象等。

区别主要体现在以下几个方面

#### 目的
+ Object Pool 主要目的是通过重用来减少创建和销毁对象的性能开销，及限制系统资源的使用。
+ Flyweight 目的在于减少大量细粒度对象的内存占用，通过共享来避免大量相似对象的冗余。

#### 共享性质
+ Object Pool 中的对象通常一次只被一个客户端使用，使用完毕后返回池中，而不是同时被多个客户端共享。
+ Flyweight 中的对象可以被许多客户端同时共享，共享的是内蕴状态，外蕴状态由客户端负责维护。

#### 适用场景
+ Object Pool 通常用于管理资源的场景，这些资源数量有限且创建开销较大。
+ Flyweight 适用于系统中存在大量相似对象，而且这些对象的状态可以分为内蕴和外蕴的场景。

#### 实现复杂性
+ Object Pool 实现相对简单，核心是维护对象集合，并提供获取和释放对象的方法。
+ Flyweight 实现相对复杂，需要维护内蕴和外蕴状态，并且要确保正确的共享和使用。

#### 生命周期管理
+ Object Pool 通常自身管理对象的生命周期，对象的生成和销毁都受池的控制。
+ Flyweight 通常由外部环境来控制对象的生命周期，Flyweight工厂只负责创建和维护共享的Flyweight对象。

尽管两种模式都在性能优化的道路上，但通过理解它们的核心区别，我们可以更好地决定在不同的场景下选择使用哪种模式。

## 参考资料
C++: [https://github.com/JakubVojvoda/design-patterns-cpp](https://github.com/JakubVojvoda/design-patterns-cpp)

Java: [https://github.com/iluwatar/java-design-patterns](https://github.com/iluwatar/java-design-patterns)

Scala: [https://github.com/nikolovivan/scala-design-patterns](https://github.com/nikolovivan/scala-design-patterns)

PHP: [https://github.com/DesignPatternsPHP/DesignPatternsPHP](https://github.com/DesignPatternsPHP/DesignPatternsPHP)

Python: [https://github.com/faif/python-patterns](https://github.com/faif/python-patterns)

Go: [https://github.com/senghoo/golang-design-pattern](https://github.com/senghoo/golang-design-pattern)

Unity: [https://github.com/QianMo/Unity-Design-Pattern](https://github.com/QianMo/Unity-Design-Pattern)

JS: [https://github.com/fbeline/design-patterns-JS](https://github.com/fbeline/design-patterns-JS)

Lua: [https://github.com/woshihuo12/LuaDesignPattern](https://github.com/woshihuo12/LuaDesignPattern)

